simu -> sync 模拟
show -> simu 跟踪
ai逻辑只能同步不能模拟，不能跟踪, ai逻辑包括hp，bAddSubHp, cd
pos，rot可以从同步模拟，可以跟踪

lastSync ---求值--- sync ---模拟---> simu ---跟踪---> show
求值:按照游戏逻辑从lastSync状态计算指定时间

11:先模拟后跟踪
01:不模拟（sync与simu立刻同步）只跟踪
10:只模拟不跟踪（show与simu立刻同步)
00:不模拟不跟踪（sync，simu，show）立刻同步

property {
    function simu();
    function follow();
}

pos: 11
rot: 11
hp: 01
cd: 00 or 01
bAddSubHp: 00 //是设置状态，用以影响精灵展示，不真正改变hp

class state {
    vector3 pos; //11
    quaternion rot; //11
    float hp; //01
    int cd; //00 or 01
    bool bAddSubHp; //00
}
服务器延迟求值
无论服务器还是所有客户端，在没有事件的情况下，能将各种状态从任一时刻计算到之后任一时刻，并且结果是一样的
这样的求值过程不依赖任何全局状态，必须是纯函数，以一组状态和一段时间作为输入，输入这组状态下在这段时间之后的状态（有点类似函数式编程的意思），此外把状态组sg(state group)计算t时间与把sg分别计算(t1, t2, t3)(其中t1 + t2 + t3 == t)的结果也是一样的
这个求值函数的作用：
>服务器可以延迟计算，不用真正实时计算状态，只有当客户端有事件到来时才从之前sync计算到当前时刻，并加入客户端事件成为sync状态，作为之后计算的基础状态
>在客户端有两个作用：一是与服务器一样，客户端收到服务器发送的客户端事件以及时间，将sync状态向后同步到这个时刻，并加入客户单事件成为sync状态，作为后面同步的基础；二是客户端同步之后，在收到下一个服务器消息之前，预测地向前模拟状态变化，模拟状态的变化同样使用这个过程计算

浮点数误差：画面展现show，可能由于网络帧延迟导致模拟帧数不同，使得cppos的值不同，经过数帧插值之后尽管几乎相等，但是还是有略微误差，然而这对于展示来说没有什么影响，几乎察觉不到。对于ai计算来说，浮点数误差非常重要，因为两个客户端如果即使有轻微的误差也可能导致不同的行为，例如判断是否落在一个冰冻法术的范围内，一个可能被判断在内，另一个则没有，而且这种误差是不可能用技巧消除的。幸运的是计算ai用的是sync，这个不会因为网络，插值等原因导致两个客户端有误差的，因为它们是严格按照帧同步来计算的。对于ai的sync，唯一导致两个客户端浮点数误差的情况就是两个客户端运行在不同的机器或语言平台上，不同机器或语言平台计算的浮点数或有不同，但是这中由于平台或机器导致的浮点数误差非常小，有效精度内是完全相同的，精度之外的误差非常小，可以忽略不计。

